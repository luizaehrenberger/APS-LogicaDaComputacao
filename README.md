# Relatório da APS – Linguagem LINHA e Máquina Virtual

Este relatório apresenta a linguagem de programação **LINHA**, desenvolvida para a APS de Lógica da Computação. A LINHA é uma linguagem de domínio específico (DSL) criada para controlar um robô seguidor de linha simples, com dois sensores de linha (esquerdo e direito), um sensor de distância frontal e dois motores. O objetivo do projeto foi cobrir todo o fluxo clássico de construção de uma linguagem: definição de gramática, análise léxica e sintática, geração de código e execução em uma máquina virtual própria.

A motivação da LINHA é, ao mesmo tempo, acadêmica e didática. Do ponto de vista acadêmico, a linguagem foi construída para atender aos requisitos da disciplina: ter uma gramática formal em EBNF, utilizar Flex para análise léxica, Bison para análise sintática e produzir um código de saída que possa ser interpretado por uma máquina virtual. Do ponto de vista didático, a LINHA foi pensada como uma ponte entre o mundo das linguagens naturais e o das linguagens de programação. Em vez de partir diretamente de linguagens complexas como C ou Java, o projeto usa um contexto concreto e intuitivo: um robô que anda, segue uma faixa no chão e desvia de obstáculos. Assim, ao ler um programa em LINHA, mesmo alguém leigo consegue imaginar fisicamente o que o robô faria.

A sintaxe da LINHA é inspirada em C, mas reduzida ao essencial. Cada comando termina com `;`, blocos são delimitados por `{` e `}`, e a linguagem oferece estruturas de controle como `if`, `else` e `while`. Há variáveis inteiras, atribuídas com o operador `=`, e expressões aritméticas com `+`, `-`, `*`, `/` e `%`. Também existem operações lógicas (`&&`, `||`, `!`) e relacionais (`>`, `<`, `>=`, `<=`, `===`, `!=`). Dessa forma, é possível escrever condições como `if (dist() < 10) { stop(); }` de maneira direta e legível. O vocabulário da linguagem é baseado no domínio do robô: comandos como `forward(vel)`, `turn_left(vel)`, `turn_right(vel)`, `stop()`, `set_speed(v_esq, v_dir)` e `sleep(ms)` representam ações físicas; já as funções `line_left()`, `line_right()` e `dist()` representam leituras de sensores, que retornam valores para serem usados em expressões e condições.

Por trás do código-fonte, a LINHA possui uma infraestrutura de compilação. O arquivo de especificação léxica `linha.l` define os padrões de tokens. O analisador léxico, gerado pelo Flex, reconhece palavras-chave (`if`, `else`, `while`, `true`, `false`, `forward`, `stop` etc.), operadores, pontuação, números inteiros e identificadores, além de ignorar espaços em branco e comentários iniciados por `//`. Em seguida, o analisador sintático, gerado pelo Bison a partir do arquivo `linha.y`, verifica se a sequência de tokens respeita a gramática da linguagem. A gramática foi estruturada em EBNF e cobre programa, comandos simples, comandos compostos, blocos, atribuições, comandos de movimento, estruturas condicionais, laços e expressões com precedência definida.

As ações semânticas do Bison, em vez de construir uma árvore de sintaxe abstrata completa, já geram diretamente um “assembly” de uma máquina virtual simples, a **LINHA-VM**. Quando o parser encontra uma atribuição, como `base = 30;`, ele produz uma linha `SET base 30` na saída. Quando encontra `forward(40);`, gera `FORWARD 40`. No caso de `set_speed(base - ganho, base + ganho);`, são geradas instruções `SET_SPEED` com os valores avaliados. Ao final da análise, se não houver erros de sintaxe, o programa imprime uma mensagem de sucesso e a saída padrão contém o programa em formato de instruções da VM, uma por linha.

A máquina virtual LINHA-VM foi implementada em C no arquivo `vm.c`. Ela lê as instruções geradas pelo compilador a partir da entrada padrão e interpreta uma a uma. A VM mantém registradores de estado simples, como `motor_left`, `motor_right` (velocidades dos motores) e `time_ms` (tempo lógico acumulado em milissegundos). Também há um armazenamento simples para variáveis declaradas via instruções `SET`. Cada linha é interpretada por meio de leitura de texto e comparação de comandos. Instruções como `FORWARD 40` fazem a VM atualizar os motores para `L=40` e `R=40` e imprimir um log do tipo `[t=0] FORWARD 40 -> L=40 R=40`. A instrução `TURN_LEFT 30` pode ser interpretada como `L=-30` e `R=30`, simulando uma curva; `SLEEP 300` aumenta o tempo lógico para `t=300`. No fim da execução, a VM imprime um resumo com o tempo total e o estado final dos motores.

Os programas de exemplo mostram como a LINHA pode expressar comportamentos típicos de um robô seguidor de linha. No exemplo de **seguir linha**, o robô anda enquanto a distância à frente for maior que um limiar, usando `line_left()` e `line_right()` para ajustar a direção. Em termos de código, isso aparece como um laço `while (dist() > 15)` que, dentro, usa `if`, `else if` e `else` para escolher entre `turn_left(30)`, `turn_right(30)` ou `forward(40)`. Ao término do laço, o programa chama `stop();`. No exemplo de **evitar obstáculo**, a lógica é reativa e contínua: um `while (true)` que verifica `if (dist() < 10)` para decidir se deve parar, esperar um pouco, virar à direita e depois retomar o movimento; caso contrário, apenas segue em frente com `forward(35)`. No exemplo de **calibração**, o foco está em variáveis e expressões aritméticas. O programa define `base = 30;` e `ganho = 10;` e, dentro de um laço infinito, ajusta as velocidades dos motores com `set_speed(base - ganho, base + ganho)`, `set_speed(base + ganho, base - ganho)` ou `set_speed(base, base)` conforme os sensores de linha. Isso ilustra como variáveis servem para parametrizar o comportamento do robô sem precisar repetir números fixos em todos os comandos.

Do ponto de vista de uso, a ferramenta é simples. No diretório `src/`, o compilador é gerado com `bison -d -o linha.tab.c linha.y` e `flex -o linha.lex.c linha.l`, e depois compilado com `gcc -o linha linha.tab.c linha.lex.c main.c -lfl`. A máquina virtual é compilada com `gcc -o vm vm.c`. Para testar, basta rodar, por exemplo, `./linha < ../Exemplos/seguir_linha.lnh > seguir_linha.vm` para gerar o código da VM, e depois `./vm < seguir_linha.vm` para interpretar e visualizar o comportamento simulado do robô.
